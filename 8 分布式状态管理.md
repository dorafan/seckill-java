项目要改为分布式管理的方式

现在最不符合分布式管理的地方就是使用了session。分布式管理一般使用token存入redis中

![image-20210502203704149](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210502203704149.png)

单机redis的实现。以及如何使用token实现登陆凭证管理

redis是k-v库，在内存中，带有持久化。 key是字符串，v有多种常用类型：字符串， 哈希（k-v对）， 列表，集合，有序集合。

本项目当作缓存用，不太关注持久化，存的都是字符串。

##### 安装配置redis

```shell
vim /etc/redis.conf

redis-server /etc/redis.conf 开启redis
redis-cli -a nowcoder123 #redis自带的ui，使用密码nowcoder123开启

keys *  #查看redis中存储的key
set cache 100 ex 30 #淘汰策略 cache-100 30秒后删除
ttl cache #查看cache变量剩余时间
flushdb #删库
```

redis自带16个库，默认是0

缓存需要设置淘汰时间

redis表之间没有什么关联



RedisAutoConfiguration类，RedisTemplate方法需要实例化，使用RedisConnectionFactory调用redis连接。

如果使用这个redis的默认方法，序列化往redis中传递的是二进制编码，很不方便查看，所以需要自己实现一个，使用注解

```java
@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
```



redis也支持简单事务，如果有好几个命令，需要编排成一个事务，就需要用一个特殊的格式来执行

```java
redisTemplate.execute(new SessionCallback() 
                      {@Override 
                          String redisKey = "test:tx"; //先声明一个key,用冒号对key名进行层级管理（也可以用其他字符）
                          public Object execute(RedisOperations operations) throws DataAccessException {
                              operations.multi();//可以认为这是开启事务
                              //这里写redis的各种操作命令
                              operations.opsForValue().set(redisKey,1);
                              operations.opsForValue().increment(redisKey);
                              operatiosn.opsForValue().decrement(redisKey);
                              //opsForValue，对字符串操作，set()存入，get()读取
                              System.out.println(operations.opsForValue().get(redisKey));//这里不会成功
                              //会返回null，因为事务还未结束
                              return operations.exec();//这里认为是结束事务
                          }
                      })
// operations 可以认为是实现各种命令的一个父接口
//在事务未结束（未提交）前，是看不到操作结果的，即在事务中间是得不到结果的
```



##### 项目使用redis

集中在controller的session处理，controller用来处理前端发来的请求，session在request里，所以应全权由controller处理



后端是如何接受到前端传过来的参数的？：应用类反射，如果前端有传过来同名的参数，就给赋值。

每一次前端请求，会把cookie也一起传过来，在request里。

至于前端是传cookie还是token，这是实现商量好的。

使用session的话，会给前端返回一个cookie，里面存储了sessionId，sessionId和token是类似的，都是字符串。



之前使用session时，后端会自动将sessionId放在cookie里传到前端，前端无需做任何处理。。

现在后端返回token，可以存到cookie里，但是安全性不好。

存到浏览器的sessionStorage里，浏览器有多个storage： local storage，session storage， indexedDB， web sql, cookie。

localstorage会一直存储，sessionstorage关闭浏览器后就丢失。这两个storage存储量比cookie大得多。

因为现在使用了token，所以每一次发送请求需要前端将token作为参数传送过去，不能像之前那样自动的将cookie从request里发送过去了。

```javascript
url: SERVER_PATH + “/order/create?token=” + sessionStorage.getItem("token")
```

这个参数的传送不会再地址栏中显示出来

当然，token可以被截获，可以被用来伪造信息，但是token中其实并没有包含任何敏感内容，仅仅是一串随机字符串。

可以通过二次验证，如ip变换，就做进一步验证。解决方法是多层安全机制，不是只靠url加密就能解决的

数据永远都有被截获的风险

因为现在不用session， 都存在了redis上，所以可以分布式部署多个tomcat。



#### redis相关问题

##### 1 redis数据类型及常用命令

​     **string最大可以存放512M的数据**

​     **集合最多2^32-1个数据**

###### string:

是redis最基础的结构，其他数据结构里都可以是string。

当然也可以将数据二进制化存入，如图片，这时要考虑容量问题

可以存储字符串，数字，二进制数据

除了值可以是string外，所有的键也可是string

string适合做缓存

###### list:

线性有序，可重复。按照自然插入顺序

一个list最多存储2^32 - 1 个元素。

支持lpush, blpush, rpop, brpop，可以用来做简单的消息队列

###### hash:

一个hash最多存2^32-1数据

###### set:

无序不可重复，

最多存2^32-1

支持多个set求交集，并集，差集，适合实现共同关注之类的需求

###### zset:

有序，不可重复，通过给每个元素设置一个分数作为排序依据。



##### 2 编码机制：

###### string：

int：条件（数据为整数值，并且可以用long类型标识）结构（long,底层是long 来实现）

raw：条件（数据为长度大于32字节的字符串）结构（SDS简单动态字符串，需要分配两块内存空间，分别存放对象元数据和字符串值）

embstr：条件（数据为长度小于等于32字节的字符串）结构（SDS简单动态字符串，需要分配一块空间，连续存放对象元数据和字符串值）

为什么需要多种实现方案？因为redis是基于内存的数据库，所以数据存储要尽可能的节约内存，也要尽可能性能好。不同的方案对应不同的策略，有点性能好，有的压缩空间

###### list:

3.2以前，采用以下两种实现

ziplist: 条件（元素数量小于512，并且每个元素长度小于64字节）（数量较少，长度较小）， 结构（压缩列表）

linkedlist：条件（不符合ziplist条件时），结构（双端列表）

3.2以后，一律按照quicklist实现

quicklist：结构（快速列表）

###### hash:

ziplist: 同上

hashtable: 条件（不符合ziplist），结构（字典）

###### set:

intset: 条件（所有元素都是整数值，且数量不超过512）， 结构（整数集合）

hashtable： 条件（不符合intset）， 结构（字典，key存储字符串，值为null）

###### zset:

ziplist： 条件（元素数量小于128， 并且每个元素长度小于64字节），结构（压缩列表）

skiplist: 条件（不符合ziplist）， 结构（字典+跳表），不用hashtable是因为它要有序，不用红黑树是因为跳表性能接近，实现起来更简单。



跳表：建立多级索引

ziplist, skiplist都比较常用。



##### 3 事务

redis提供的是简单的事务，它不支持回滚，且通常不支持acid中的d（持久性）

命令：

multi: 使得客户端进入事务模式，此时客户端的所有命令会被有顺序的放入一个事务队列中，

exec:  执行当前驶入，即将事务队列中的命令批量发送给服务端

discard： 清空事务队列中已有的命令，并让客户端退出事务模式

watch: 加乐观锁（不加悲观锁是因为会影响性能）， 要求服务器对多个key进行监视，若在执行事务之前这些key发生变化，则拒绝执行本次事务



一般使用前两个命令。

redis可以做持久化，但是做持久化时会把数据先写入页缓存中，再写到磁盘，是基于操作系统的。如果每一次命令都刷盘，redis的性能优势就无了。不可能每次操作都刷盘，可能会一段时间刷一次，这样并不完全支持持久性，中间可能会出现数据丢失。



所以在multi()与exec()之间取操作中的数据是娶不到的，因为这时命令还在事务队列中



##### 4 线程模型

###### 单线程的前提

redis的网络IO和键值对读写时由一个线程来完成的。

redis的其他功能，如持久化，异步删除，集群数据同步等，则依赖其他线程来执行

redis 应用确切的说并不是单线程的，它内部也有其他线程来完成其他功能，但是主要的业务是由单线程完成的

###### 单线程的劣势

单线程可以简化数据结构和算法的实现， 并且可以避免线程切换和竞争造成的消耗。

如果某个命令执行的是加你过长， 会造成其他命令的阻塞

虽然redis基于内存，一般的命令会比较快，但是也有命令执行会非常慢，就会阻塞。执行命令时同样要考虑避免阻塞

###### 单线程的IO模型

redis大部分操作实在内存上完成的。

redis采用了**IO多路复用机制**，可以并发处理大量的客户端请求；（redis支撑并发的原理）



##### redisIO多路复用，单线程实现原理

redis是怎么用IO多路服用实现高并发的？：

![image-20210502203023618](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210502203023618.png)

基于IO多路复用，可以实现同一个线程并发处理多个请求，处理请求的组件(socket) 

redis在应对客户端请求时是通过套接字去处理的。

因为数据传输时比较慢的，所以当数据还在传输时，socket处于空想状态，我们没必要一直监视处理socket，只要在几个关键的时刻进行处理。 即（连接上，连接关闭，已经接收到客户端数据正在写入，客户端想读取数据而数据已经准备好通过socket返回）

用一个线程去监听socket是否处于这四种状态，需要处理时才处理。

因此需要 IO多路复用程序（是一个线程）来监听socket。

监听到这几类事务时，IO多路复用程序将socket对象放入 套接字队列中，进行有序处理。 

另一个组件 文件事件分派器， 用来负责socket的具体处理（通过读取队列）（是单线程的）（底层有不同的组件分别对应不同的事件）

底层的事件处理器一般有 （命令请求处理器，命令回复处理器，连接应答处理器等）



服务器是基于多个socket与客户端相连的，



IO多路复用程序的底层是基于操作系统给的IO多路复用机制来实现的。

操作系统对IO多路复用有多种实现机制（select, epoll, evport, kqueue）， redis都支持，并且都提供了接口

**尤其注意一下epoll**

