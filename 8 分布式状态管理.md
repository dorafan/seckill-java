项目要改为分布式管理的方式

现在最不符合分布式管理的地方就是使用了session。分布式管理一般使用token存入redis中

![image-20210502203704149](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210502203704149.png)

单机redis的实现。以及如何使用token实现登陆凭证管理

redis是k-v库，在内存中，带有持久化。 key是字符串，v有多种常用类型：字符串， 哈希（k-v对）， 列表，集合，有序集合。

本项目当作缓存用，不太关注持久化，存的都是字符串。

### 安装配置redis

```shell
vim /etc/redis.conf

redis-server /etc/redis.conf 开启redis
redis-cli -a nowcoder123 #redis自带的ui，使用密码nowcoder123开启

keys *  #查看redis中存储的key
set cache 100 ex 30 #淘汰策略 cache-100 30秒后删除
ttl cache #查看cache变量剩余时间
flushdb #删库
```

redis自带16个库，默认是0

缓存需要设置淘汰时间

redis表之间没有什么关联



RedisAutoConfiguration类，RedisTemplate方法需要实例化，使用RedisConnectionFactory调用redis连接。

如果使用这个redis的默认方法，序列化往redis中传递的是二进制编码，很不方便查看，所以需要自己实现一个，使用注解

```java
@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
```



redis也支持简单事务，如果有好几个命令，需要编排成一个事务，就需要用一个特殊的格式来执行

```java
redisTemplate.execute(new SessionCallback() 
                      {@Override 
                          String redisKey = "test:tx"; //先声明一个key,用冒号对key名进行层级管理（也可以用其他字符）
                          public Object execute(RedisOperations operations) throws DataAccessException {
                              operations.multi();//可以认为这是开启事务
                              //这里写redis的各种操作命令
                              operations.opsForValue().set(redisKey,1);
                              operations.opsForValue().increment(redisKey);
                              operatiosn.opsForValue().decrement(redisKey);
                              //opsForValue，对字符串操作，set()存入，get()读取
                              System.out.println(operations.opsForValue().get(redisKey));//这里不会成功
                              //会返回null，因为事务还未结束
                              return operations.exec();//这里认为是结束事务
                          }
                      })
// operations 可以认为是实现各种命令的一个父接口
//在事务未结束（未提交）前，是看不到操作结果的，即在事务中间是得不到结果的
```



### 项目使用redis

集中在controller的session处理，controller用来处理前端发来的请求，session在request里，所以应全权由controller处理



后端是如何接受到前端传过来的参数的？：应用类反射，如果前端有传过来同名的参数，就给赋值。

每一次前端请求，会把cookie也一起传过来，在request里。

至于前端是传cookie还是token，这是实现商量好的。

使用session的话，会给前端返回一个cookie，里面存储了sessionId，sessionId和token是类似的，都是字符串。



之前使用session时，后端会自动将sessionId放在cookie里传到前端，前端无需做任何处理。。

现在后端返回token，可以存到cookie里，但是安全性不好。

存到浏览器的sessionStorage里，浏览器有多个storage： local storage，session storage， indexedDB， web sql, cookie。

localstorage会一直存储，sessionstorage关闭浏览器后就丢失。这两个storage存储量比cookie大得多。

因为现在使用了token，所以每一次发送请求需要前端将token作为参数传送过去，不能像之前那样自动的将cookie从request里发送过去了。

```javascript
url: SERVER_PATH + “/order/create?token=” + sessionStorage.getItem("token")
```

这个参数的传送不会再地址栏中显示出来

当然，token可以被截获，可以被用来伪造信息，但是token中其实并没有包含任何敏感内容，仅仅是一串随机字符串。

可以通过二次验证，如ip变换，就做进一步验证。解决方法是多层安全机制，不是只靠url加密就能解决的

数据永远都有被截获的风险

因为现在不用session， 都存在了redis上，所以可以分布式部署多个tomcat。



![image-20210503223650316](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210503223650316.png)

### redis相关问题

#### 1 redis数据类型及常用命令

​     **string最大可以存放512M的数据**

​     **集合最多2^32-1个数据**

![image-20210504014835089](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504014835089.png)

###### string:

是redis最基础的结构，其他数据结构里都可以是string。

当然也可以将数据二进制化存入，如图片，这时要考虑容量问题

可以存储字符串，数字，二进制数据

除了值可以是string外，所有的键也可是string

string适合做缓存

###### list:

线性有序，可重复。按照自然插入顺序

一个list最多存储2^32 - 1 个元素。

支持lpush, blpush, rpop, brpop，可以用来做简单的消息队列

###### hash:

一个hash最多存2^32-1数据

###### set:

无序不可重复，

最多存2^32-1

支持多个set求交集，并集，差集，适合实现共同关注之类的需求

###### zset:

有序，不可重复，通过给每个元素设置一个分数作为排序依据。



#### 2 编码机制：

![image-20210504014939990](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504014939990.png)

###### string：

int：条件（数据为整数值，并且可以用long类型标识）结构（long,底层是long 来实现）

raw：条件（数据为长度大于32字节的字符串）结构（SDS简单动态字符串，需要分配两块内存空间，分别存放对象元数据和字符串值）

embstr：条件（数据为长度小于等于32字节的字符串）结构（SDS简单动态字符串，需要分配一块空间，连续存放对象元数据和字符串值）

为什么需要多种实现方案？因为redis是基于内存的数据库，所以数据存储要尽可能的节约内存，也要尽可能性能好。不同的方案对应不同的策略，有点性能好，有的压缩空间

###### list:

3.2以前，采用以下两种实现

ziplist: 条件（元素数量小于512，并且每个元素长度小于64字节）（数量较少，长度较小）， 结构（压缩列表）

linkedlist：条件（不符合ziplist条件时），结构（双端列表）

3.2以后，一律按照quicklist实现

quicklist：结构（快速列表）

###### hash:

ziplist: 同上

hashtable: 条件（不符合ziplist），结构（字典）

###### set:

intset: 条件（所有元素都是整数值，且数量不超过512）， 结构（整数集合）

hashtable： 条件（不符合intset）， 结构（字典，key存储字符串，值为null）

###### zset:

ziplist： 条件（元素数量小于128， 并且每个元素长度小于64字节），结构（压缩列表）

skiplist: 条件（不符合ziplist）， 结构（字典+跳表），不用hashtable是因为它要有序，不用红黑树是因为跳表性能接近，实现起来更简单。



跳表：建立多级索引

ziplist, skiplist都比较常用。



#### 3 事务

![image-20210504015017877](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504015017877.png)

​		**redis提供的是简单的事务，它不支持回滚，且通常不支持acid中的d（持久性）**

命令：

multi: 使得客户端进入事务模式，此时客户端的所有命令会被有顺序的放入一个事务队列中，

exec:  执行当前驶入，即将事务队列中的命令批量发送给服务端

discard： 清空事务队列中已有的命令，并让客户端退出事务模式

watch: 加乐观锁（不加悲观锁是因为会影响性能）， 要求服务器对多个key进行监视，若在执行事务之前这些key发生变化，则拒绝执行本次事务



一般使用前两个命令。

redis可以做持久化，但是做持久化时会把数据先写入页缓存中，再写到磁盘，是基于操作系统的。如果每一次命令都刷盘，redis的性能优势就无了。不可能每次操作都刷盘，可能会一段时间刷一次，这样并不完全支持持久性，中间可能会出现数据丢失。



所以在multi()与exec()之间取操作中的数据是娶不到的，因为这时命令还在事务队列中



#### 4 线程模型

![image-20210504015101549](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504015101549.png)

##### 单线程的前提

redis的网络IO和键值对读写时由一个线程来完成的。

redis的其他功能，如持久化，异步删除，集群数据同步等，则依赖其他线程来执行

redis 应用确切的说并不是单线程的，它内部也有其他线程来完成其他功能，但是主要的业务是由单线程完成的

##### 单线程的劣势

单线程可以简化数据结构和算法的实现， 并且可以避免线程切换和竞争造成的消耗。

如果某个命令执行的是加你过长， 会造成其他命令的阻塞

虽然redis基于内存，一般的命令会比较快，但是也有命令执行会非常慢，就会阻塞。执行命令时同样要考虑避免阻塞

##### 单线程的IO模型

redis大部分操作实在内存上完成的。

redis采用了**IO多路复用机制**，可以并发处理大量的客户端请求；（redis支撑并发的原理）



##### redisIO多路复用，单线程实现原理

redis是怎么用IO多路服用实现高并发的？：

![image-20210502203023618](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210502203023618.png)

基于IO多路复用，可以实现同一个线程并发处理多个请求，处理请求的组件(socket) 

redis在应对客户端请求时是通过套接字去处理的。

因为数据传输时比较慢的，所以当数据还在传输时，socket处于空想状态，我们没必要一直监视处理socket，只要在几个关键的时刻进行处理。 即（连接上，连接关闭，已经接收到客户端数据正在写入，客户端想读取数据而数据已经准备好通过socket返回）

用一个线程去监听socket是否处于这四种状态，需要处理时才处理。

因此需要 IO多路复用程序（是一个线程）来监听socket。

监听到这几类事务时，IO多路复用程序将socket对象放入 套接字队列中，进行有序处理。 

另一个组件 文件事件分派器， 用来负责socket的具体处理（通过读取队列）（是单线程的）（底层有不同的组件分别对应不同的事件）

底层的事件处理器一般有 （命令请求处理器，命令回复处理器，连接应答处理器等）



服务器是基于多个socket与客户端相连的，



IO多路复用程序的底层是基于操作系统给的IO多路复用机制来实现的。

操作系统对IO多路复用有多种实现机制（select, epoll, evport, kqueue）， redis都支持，并且都提供了接口

**尤其注意一下epoll**





微服务是因为企业级项目实在是太大了，业务模块太多难以维护开发，需要进行业务拆分，而这会给开发带来更大的难度

微服务一定是基于分布式的。





#### 5 redis持久化机制

![image-20210504002931601](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504002931601.png)

redis支持的类型多

redis可以持久化，在保证性能的情况下，最多丢1秒的数据。其实可以做到不丢数据，但是影响性能。

rdb适合备份，但是rdb阻塞严重。

##### rdb aof 区别

rdb aof底层都有阻塞时机。 基于redis 的线程模型，阻塞对性能的影响非常大。所以必须清楚redis持久化机制，因为持久化恰恰会产生较大的阻塞



![image-20210504003732745](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504003732745.png)

##### RDB持久化  BGSAVE命令：

1	BGSAVE命令会通知redis的主进程（父进程）去fork出一个子进程，利用子进程来做持久化。因为直接让主进程来做的话就会阻塞对当前命令的响应。

如果子进程已经有了，那么就直接返回

2	父进程在创建子进程的那一刻，父进程阻塞，无法响应客户端的请求，

3	 父进程在fork子进程后就可以继续响应其他命令，阻塞接触

4	子进程要做的就是将数据存到硬盘中的文件里，这里称为RDB文件，这一步可以和3并存。 它会读取父进程的数据存入硬盘

5	4完成后，通知父进程替换旧的文件



3 4 一致性问题如何解决？

###### CopyOnWrite 

写时复制，操作系统的东西

内存的最小的管理单元是页page， 

如果子进程读，父进程写同一页，这时用到了写时复制机制。

谁要改动某一页，就把这一页copy到一个副本，写入副本，子进程读页，父进程写的是副本

快照机制，在这一刻内存数据相当于被锁住，无法进行更改，要改就用副本。



副本在修改后，并不是直接写回。 对于父进程来说，内存管理已经变了，副本是完全替代品。旧的page在子进程读完后可以释放回收了。



**如果redis在运行过程中出问题，去/var/log/redis/redis.log查看**、



##### aof持久化：

aof的重写机制，会产生阻塞。 因为它是基于命令的。

很多命令是冗余的，可能只需要保留最后一条命令。aof有机制进行压缩。

aof并不是通过分析log来找每一条数据的冗余，而是直接依据内存中现有的数据，生成一个新的log代替旧的log。

![image-20210504010601814](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504010601814.png)

###### aof流程：

每次进行写入时，redis会先把命令缓存起来，而不是直接写入磁盘，是从缓冲区按一定频率刷入磁盘（自己配置）（也可以每次命令都刷 / 缓冲区满了就刷，交给操作系统）。缓冲区是aof_buf。

缓冲区要进行同步到磁盘文件里 AOF文件。

当重启服务，会自动读取数据

###### aof重写：

aof重写基于bgrewriteaof命令，系统自动调用

1	通知父进程

2	fork子进程，父进程此刻阻塞

3	父进程可以继续往aof_buf写数据，同时



如果这时子进程将快照写新文件，而父进程同时又有操作，这个操作将写入旧文件，替换文件将产生数据丢失。如何解决？



4	当父进程在3中响应请求，写入aof_buf中时，为了避免上述问题，会同时写入rewrite_buf中。 3 4同时进行

5	子进程将此刻的快照数据写入新AOF文件，而不是分析旧AOF文件的冗余

6	子进程通知父进程

7	将rewrite_buf 同步进新AOF文件

8	替换AOF文件



aof中，必须要做的是持久化aof文件，其他黄色区域都只是为了重写/压缩文件

RDB中，必须要做的是持久化快照数据



##### 混合持久化



#### 6 分布式缓存

##### 缓存淘汰策略

###### 数据过期策略

被动淘汰

![image-20210504013803717](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504013803717.png)

惰性删除有一个问题，缓存中会有大量过期数据占用内存空间，所以有定期删除策略做补充

###### 内存淘汰策略

主动淘汰，比如缓存存满，溢出了

![image-20210504014124056](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504014124056.png)

LRU有一个问题，就是某个数据可能恰巧刚刚访问，被标记为了频繁使用，但其实不是。

LFU算法：

先统计访问次数，将访问次数最低的数据淘汰；

若访问次数相同，则按照访问时间，吧访问时间更早的数据淘汰（LRU）



##### 缓存与数据库的同步

![image-20210504014640532](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504014640532.png)

###### 同步策略

哪种策略更好？

###### 建议方式

![image-20210504015431160](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504015431160.png)

假设第2步失败的情况，先更新数据库再删缓存好

![image-20210504020143469](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504020143469.png)

假设第2步成功， 依然会出现不同步



##### 分布式缓存的常见问题

![image-20210504020545114](8%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.assets/image-20210504020545114.png)