![image-20210428164559905](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210428164559905.png)

spring的事务操作，基于Mysql， innoDB引擎的事务的支持



秒杀的实际行动（扣减库存）放在了下单的环节，也有的放在了付款环节

下单时减库存，可能会出现少卖的环节。 （下单时就锁定了库存，一定不会超卖，但是有的人不一定会付款）（超时未付款订单要失效，库存回滚）

付款时减库存，会出现超卖 （下单的人超过库存，但是扣减库存数量在付款阶段）



订单数据表： 下单id， 用户id，商品id，优惠Id，商品下单时价格，

订单id前几位为日期，这样处理方便以后拆分（比如查半年前的订单数据，许多网站要额外操作，因为数据被转移了）



serial number表：

因为订单id永远自增1，所以设计一个表，记录下一个订单id的流水号，防止丢失订单信息。每次生成订单前查流水号确定订单ID，查找的时候使用for update加锁，为之后的更改做准备

不只是订单号，凡是想要永久存储一个序号的当前最大序号，都可以用，步长step是每次应该加的值，



MySQL 排他锁 serialNumberMapper.xml，在查询订单id 的时候where语句后加 for update，因为查完进阶着要下单







## InnoDB事务

innodb引擎支持高性能事务。

MVCC：极其重要，MySQL通过它，既保证了事务，又保证了并发性

很多数据库在默认的隔离级别下，是不完全满足隔离性的，不是完全的acid （为了性能）。

MySQL在完全满足acid，性能依然很好。

acid原理是什么？

#### 原子性atomic：







#### 一致性consistency：

![image-20210429124943397](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429124943397.png)











#### 隔离性isolation：

<img src="6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429125107778.png" alt="image-20210429125107778" style="zoom:150%;" />

隔离性是通过锁实现的

##### lock：

###### 粒度，锁类型

![image-20210429130742378](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429130742378.png)

MySQL支持行锁，表锁。（表锁底层是基于页的，不是整个表，很多时候没必要锁整个表）（行锁很多时候也是锁一页，该行上下的相关数据都锁起来）。

排他锁：一旦加了就丧失并发性，因为禁止读；

IX锁：与行锁互斥。

意向锁：准备干什么，具体要开始做的时候得再加行锁

那么如何在加锁的情况下提升并发性：

###### 锁的实现机制，mvcc

![image-20210429132533773](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429132533773.png)

提升并发性的机制就是能不加锁就不加。

比如想要update一行数据，要对该行加x锁。这时他会复制该行数据，形成一个新的版本，在新版本加x锁，其他事务想要读取的话，读的是历史数据，

版本生成是通过日志来读取实现的。

如果想现式加锁，那么在查的时候也可以加x锁。

能否在加了x锁的时候去读，取决于隔离级别，有的隔离级别允许，有的不允许

###### 锁的算法：MySQL内置了三种算法实现锁的机制

![image-20210429133109184](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429133109184.png)

###### ![image-20210429133848024](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429133848024.png)

脏读：一个事务读到了另一个事务正在改，未提交的数据。一定要杜绝。

不可重复读： 同一个事务内，多次读取某一个的数据应该前后一致。读到旧数据，那就都读旧的，不能一半旧一半新。

幻读：前后数据未变，但是数据范围变了。

| 脏读：某一个事务，读取了另外一个事务中未提交的数据。         |              |                         |
| ------------------------------------------------------------ | ------------ | ----------------------- |
| 时刻                                                         | 事务1        | 事务2                   |
| T1                                                           | Read: N=10   |                         |
| T2                                                           | Write: N=11  |                         |
| T3                                                           |              | Read: N=11              |
|                                                              |              |                         |
| 不可重复读：某一个事务，对同一个数据前后读取的结果不一致。   |              |                         |
| 时刻                                                         | 事务1        | 事务2                   |
| T1                                                           | Read: N=10   |                         |
| T2                                                           |              | Read: N=10              |
| T3                                                           | Write: N=11  |                         |
| T4                                                           | Commit       |                         |
| T5                                                           |              | Read: N=11              |
|                                                              |              |                         |
| 幻读：某一个事务，对同一个表前后查询到的行数不一致。         |              |                         |
| 时刻                                                         | 事务1        | 事务2                   |
| T1                                                           |              | Select:  id<10(1,2,3)   |
| T2                                                           | Insert: id=4 |                         |
| T3                                                           | Commit       |                         |
| T4                                                           |              | Select:  id<10(1,2,3,4) |
|                                                              |              |                         |
| 第一类丢失更新：某一个事务的回滚，导致另外一个事务已更新的数据丢失了。 |              |                         |
| 时刻                                                         | 事务1        | 事务2                   |
| T1                                                           | Read: N=10   |                         |
| T2                                                           |              | Read: N=10              |
| T3                                                           |              | Write: N=9              |
| T4                                                           |              | Commit                  |
| T5                                                           | Write: N=11  |                         |
| T6                                                           | RollBack     |                         |
|                                                              |              |                         |
| 第二类丢失更新：某一个事务的提交，导致另外一个事务已更新的数据丢失了。 |              |                         |
| 时刻                                                         | 事务1        | 事务2                   |
| T1                                                           | Read: N=10   |                         |
| T2                                                           |              | Read: N=10              |
| T3                                                           |              | Write: N=9              |
| T4                                                           |              | Commit                  |
| T5                                                           | Write: N=11  |                         |
| T6                                                           | Commit       |                         |
|                                                              |              |                         |

###### 死锁：

![image-20210429134857296](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429134857296.png)

死锁释放：超时回滚（当一个事务的操作时间超时，谁的锁的范围更大，谁先释放），这是被动的。

​                   死锁检测 （一旦发现两个事务间出现回路，就有可能有死锁）

###### 锁升级：

![image-20210429135159279](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429135159279.png)

innoDB不存在锁升级（行锁升级到表锁），因为其不是根据每个记录来产生锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。 因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

##### 隔离级别：

![image-20210429125217649](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429125217649.png)



read commited： 锁住正在更改的那一行（解决脏读，其他事务读不到正在更改的未提交的数据），其他事务读快照中的历史数据（mvcc支持并发性）

repeatable read：解决了所有问题，默认隔离级别。首先锁住该行，解决了脏读。又因为锁住了范围数据，其他事务读历史版本不会出现幻读，和不可重复读。启用mvcc支持并发性。

serializable：读的时候就加锁，解决所有问题



#### 持久性：

![image-20210429125333373](6%20%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E4%B8%8E%E7%A7%92%E6%9D%80.assets/image-20210429125333373.png)