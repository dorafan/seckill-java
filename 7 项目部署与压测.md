#### 部署的过程是复习Linux常用命令：

![image-20210429165010987](7%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8E%8B%E6%B5%8B.assets/image-20210429165010987.png)

不同端口负责不同服务，也可以使用路径进行区分。



maven打包：

```
mvn clean package -Dmaven.test.skip=true
```

将target文件下打好的jar包上传到/root目录下



服务器安装jdk

```
yum list java*
yun install -y 
```



编写启动脚本startup.sh

安装nginx

在本地安装jmeter

给startup.sh分配权限

```
chmod -R 777 startup.sh
```

启动

```
sh startup.sh
```

控制台信息会被打印到nohup.out里

查看

```
tail nohup.out
```

tomcat默认端口8080

启动nginx

```
nginx -c /etc/nginx/nginx.conf
```

这是访问ip会看到nginx的页面， 这个默认页面在  /usr/share/nginx/html/index.html



我们需要把前端代码放在该文件夹下

之后修改配置：

更改common,.js，修改访问路径为服务器ip:90端口



对nginx进行配置，

转发80到seckill_site,转发90到8080

重启nginx， 

```
nginx -s reload
```



压测前看linux状态

```
top -H
```

观察load average, 1 5 15分钟内cpu负载

cpu占用百分比不应100%， running不应超过内核数

进程中注意不要频繁访问mysql



压测查询，直到报错。



压测下单。



#### 热点问题；

分布式情况怎么处理？

读写分离

Mysql如何实现分布式事务，原理是什么？

![image-20210429202304046](7%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8E%8B%E6%B5%8B.assets/image-20210429202304046.png)

nginx可以做集群，也可以做热备，都在监听80端口，谁抢到谁就是主服务器，如果有一个出现异常，另一个立刻接管。

MySQL如果要做分布式，就得处理分布式事务。

如果要拆分，尽量做业务拆分，相互不影响。

MySQL读写分离：

​	向主服务器写，通过线程与从服务器进行同步，通过从服务器读。



通过缓存提高MySQL性能。

二级缓存，第一级时guava cache，与tomcat同在本地，占用java web内存。

如何让功能之间解耦——rocketmq 异步处理。



当前项目是把所有的功能部署在同一台服务器上。

通过两级缓存，提高了查询的性能

通过缓存+异步的方式，提高了持久化（下单）的性能

分布式部署tomcat，提高单机瓶颈，提高流量。



##### MySQL读写分离：

![image-20210429203402058](7%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8E%8B%E6%B5%8B.assets/image-20210429203402058.png)

基于主从架构，

从服务器不但要被读，还要同步数据。

从服务器读到bin log后，会将其存入relay log 中继日志。 当有外部访问想要读数据，就会从从服务器的sql线程中，从relay log读取数据。

从服务器还负责生成快照，备份某一时刻的数据。（做备份是因为如果主服务器发生错误，需要用从服务器的快照进行恢复）

主从模式是基于两个log实现的。



如果读写分离不够用，就用分布式。

通过业务进行拆分，使得一类业务在一个服务器中，

如果不能这么拆，则必须做分布式事务。



##### 数据库分布式事务

![image-20210429204103584](7%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8E%8B%E6%B5%8B.assets/image-20210429204103584.png)

数据库的分布式事务可以跨不同的数据库，场景（跨行转账，不同银行用不一样的数据库）

这个和rocketmq的事务性消息，是类似的。

​	**核心是两阶段提交。**



资源管理器就是数据库（也可能是rocketmq等其他东西）（要实现分布式事务的数据库），

事务管理器用于协调资源管理器的分布式事务（管理分布式事务实现的协调放）

应用程序时需求方（在什么情况下做分布式事务）

2 事务管理器向每一个资源管理器发送start命令，提示要开始了，

3 应用程序依次向每一个资源管理器做sql操作，未commit

4 应用程序执行完后，事务管理器向资源管理器发送end命令，同时记录下这段时间资源管理器都做了哪些工作

5 发送prepared命令，资源管理器检查sql有无执行完毕，是否可以commit,  （commit要做到原子性）

6 如果所有资源管理器都响应准备完毕，那么事务管理器发送commit指令，否则任一未准备好，就发送rollback指令



在同一调度下，数据库做到了同步

如果事务管理器出现异常呢？如果指令发送失败了呢（丢包）？

这种机制不是完美的。

可以在应用程序里加入重置机制



上述机制是外部分布式事务，mysql还有内部的分布式事务管理



###### MySQL内部分布式事务

主要发生在读写分离时

<img src="7%20%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8E%8B%E6%B5%8B.assets/image-20210502201927437.png" alt="image-20210502201927437" style="zoom: 50%;" />

主服务器记录bin log, 从服务器读取并复制到redo log，同时主服务器为了持久性，innodb 会记录redo log（在commit之后写）。

假设redo log记录失败？（内部分布式事务解决的就是bin log 与 redo log 不同步的问题）

这是两个不同模块之间的行为（数据库层面和引擎层面）

1 innodb 会prepare（在记录之前）

2 写bin log

3 同步到relay log

4 写redo log

因为有了prepare，即使redo log写失败，也可以从bin log恢复。

这是内部分布式事务。



读写分离没有分布式事务，因为读服务器只是在拷贝数据而已。分布式数据库有数据库之间同步数据的问题。